rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    function getUserRole() {
      // Caches the result of the get() call for the duration of the request evaluation.
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isOneOfRoles(roles) {
      // Ensure user is authenticated before checking role.
      return request.auth != null && getUserRole() in roles;
    }

    match /users/{userId} {
      // Any authenticated user can read any user profile.
      // The UI logic restricts who can see which lists of users.
      // This is safe and prevents rule recursion issues that caused previous errors.
      allow read: if request.auth != null;

      // Only MasterAdmin can create, update, or delete users directly.
      // Admins must use the approval request flow.
      allow write: if isOneOfRoles(['MasterAdmin']);
    }

    match /approval_requests/{requestId} {
      // READ (get, list): MasterAdmin can read all. Admins can read requests they created.
      // This rule works for both get() and list() queries because a client-side query
      // from an Admin will include `where('requestedByUid', '==', request.auth.uid)`,
      // which Firestore can validate against this rule.
      allow read: if request.auth != null && (
        isOneOfRoles(['MasterAdmin']) ||
        resource.data.requestedByUid == request.auth.uid
      );
      
      // CREATE: Admin/MasterAdmin can create. Must be for themselves.
      allow create: if request.auth != null &&
        isOneOfRoles(['Admin', 'MasterAdmin']) &&
        request.resource.data.requestedByUid == request.auth.uid;

      // UPDATE: Only MasterAdmin can approve/reject.
      allow update: if isOneOfRoles(['MasterAdmin']);
      
      // DELETE: Not allowed for data integrity.
      allow delete: if false;
    }

    match /attendance/{attendanceId} {
      // READ: PICs/Admins/MasterAdmins can read all. Kurir can read their own.
      allow read: if request.auth != null && (
        isOneOfRoles(['PIC', 'Admin', 'MasterAdmin']) ||
        (isOneOfRoles(['Kurir']) && resource.data.kurirUid == request.auth.uid)
      );

      // WRITE: A Kurir can only create/update their own record.
      allow write: if request.auth != null &&
        isOneOfRoles(['Kurir']) &&
        // For create, check incoming data. For update, check existing data.
        (request.resource.data.kurirUid == request.auth.uid || resource.data.kurirUid == request.auth.uid);
        
      allow delete: if false;
    }

    match /kurir_daily_tasks/{taskId} {
      // READ: PIC/Admin/MasterAdmin can read all. Kurir can read their own.
      allow read: if request.auth != null && (
        isOneOfRoles(['PIC', 'Admin', 'MasterAdmin']) ||
        (isOneOfRoles(['Kurir']) && resource.data.kurirUid == request.auth.uid)
      );
      // WRITE: Kurir can write to their own task.
      allow write: if request.auth != null &&
        isOneOfRoles(['Kurir']) &&
        // Using `getAfter` to check data both on create and update
        getAfter(/databases/$(database)/documents/kurir_daily_tasks/$(taskId)).data.kurirUid == request.auth.uid;

      match /packages/{packageId} {
         // Allow read/write if the user has access to the parent task document.
        allow read, write: if request.auth != null &&
          get(/databases/$(database)/documents/kurir_daily_tasks/$(taskId)).data.kurirUid == request.auth.uid;
      }
    }
    
    match /notifications/{notificationId} {
      allow read, write: if isOneOfRoles(['MasterAdmin']);
    }
  }
}
